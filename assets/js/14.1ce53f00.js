(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{411:function(v,_,e){"use strict";e.r(_);var t=e(2),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"tcp三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[v._v("#")]),v._v(" TCP三次握手")]),v._v(" "),_("p",[v._v("传输控制协议"),_("code",[v._v("TCP")]),v._v(","),_("code",[v._v("Transmission Control Protocol")]),v._v("是一种面向连接的,可靠的，基于字节流的传输层通讯协议，其运行在"),_("code",[v._v("OSI")]),v._v("七层模型中的传输层，为了在不可靠的互联网络上提供可靠的端到端的字节流而专门设计的一个传输协议。")]),v._v(" "),_("h2",{attrs:{id:"tcp头格式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp头格式"}},[v._v("#")]),v._v(" TCP头格式")]),v._v(" "),_("p",[_("em",[v._v("序列号")]),v._v("： 在建立链接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小。用来解决网络包乱序问题")]),v._v(" "),_("p",[_("em",[v._v("确认应答号")]),v._v("： 指下次期望收到的数据的序列号，发送端收到这个确认应答号以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包问题")]),v._v(" "),_("p",[_("em",[v._v("控制位")]),v._v(":")]),v._v(" "),_("ul",[_("li",[_("em",[v._v("ACK")]),v._v(": 该位为1时，确认应答的字段变为有效，"),_("code",[v._v("TCP")]),v._v("规定除了最初建立链接时，"),_("code",[v._v("SYN")]),v._v("包之外该位必须设置为1。")]),v._v(" "),_("li",[_("em",[v._v("RST")]),v._v(": 该位为1时，表示"),_("code",[v._v("TCP")]),v._v("链接中出现了异常必须强制断开链接")]),v._v(" "),_("li",[_("em",[v._v("SYN")]),v._v(": 该位为1时，表示希望建立连接，并在其序列号的字段进行序列号初始值的设定")]),v._v(" "),_("li",[_("em",[v._v("FIN")]),v._v(": 该位为1时，表示今后不会再有数据发送，希望断开链接。当通讯结束希望断开连接时，通讯双方的主机之间就会相互交互"),_("code",[v._v("FIN")]),v._v("为1的"),_("code",[v._v("TCP")]),v._v("段")])]),v._v(" "),_("h2",{attrs:{id:"为什么需要tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要tcp"}},[v._v("#")]),v._v(" 为什么需要TCP")]),v._v(" "),_("p",[_("code",[v._v("IP")]),v._v("层是不可靠的，它不保证网络包的交付，不保证网络包的按序交付，也不保证网络包中的数据完整性。如果需要保证网络包的可靠性，那么需要上层"),_("em",[v._v("传输层")]),v._v("的"),_("code",[v._v("TCP")]),v._v("协议。")]),v._v(" "),_("h2",{attrs:{id:"什么是tcp连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是tcp连接"}},[v._v("#")]),v._v(" 什么是TCP连接")]),v._v(" "),_("p",[v._v("用来保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket,序列号和窗口大小称为连接。")]),v._v(" "),_("p",[v._v("所以我们可以知道，建立一个"),_("code",[v._v("TCP")]),v._v("连接时需要客户端和服务端达成三个共识")]),v._v(" "),_("ul",[_("li",[v._v("Socket: 由IP地址和端口号组成")]),v._v(" "),_("li",[v._v("序列号: 用来解决乱序问题")]),v._v(" "),_("li",[v._v("窗口大小: 用来做流量控制")])]),v._v(" "),_("h2",{attrs:{id:"三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[v._v("#")]),v._v(" 三次握手")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("client                                      server\n主动打开 →          SYN=1,seq=x          → 被动打开，接收\n(同步已发送)                               (同步收到)\n接收     ←   SYN=1,ACK=1,seq=y,ack=x+1   ← 发送\n(已建立链接)                               (同步收到)\n发送     →      ACK=1,seq=x+1,ack=y+1    →  接收\n(已建立链接)                               (已建立链接)\n")])])]),_("ul",[_("li",[v._v("第一次握手：客户端主动连接服务端，发送初识序列号"),_("code",[v._v("seq=x")]),v._v("与"),_("code",[v._v("SYN=1")]),v._v("同步请求标识，并进入同步已发送"),_("code",[v._v("SYN-SENT")]),v._v("状态，等待服务端确认")]),v._v(" "),_("li",[v._v("第二次握手：服务端收到消息后发送确认标识"),_("code",[v._v("ACK=1")]),v._v("与同步请求标识"),_("code",[v._v("SYN=1")]),v._v("，发送自己的序列号"),_("code",[v._v("seq=y")]),v._v("以及客户端确认序列号"),_("code",[v._v("ack=x+1")]),v._v(",此时服务端进入同步收到"),_("code",[v._v("SYN-RECV")])]),v._v(" "),_("li",[v._v("第三次握手：客户端收到后发送确认标识"),_("code",[v._v("ACK=1")]),v._v(",发送自己的序列号"),_("code",[v._v("seq=x+1")]),v._v("与服务端确认号"),_("code",[v._v("ack=x+1")]),v._v("，发送过后进入确认链接已建立状态"),_("code",[v._v("ESTABLTSHED")])])]),v._v(" "),_("h2",{attrs:{id:"为什么是三次握手-不是两次-四次"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么是三次握手-不是两次-四次"}},[v._v("#")]),v._v(" 为什么是三次握手？不是两次，四次？")]),v._v(" "),_("p",[_("em",[v._v("防止历史链接初始化了链接")]),v._v("\n如果两次握手的情况下，服务端没有中间状态给客户端来阻止历史链接，导致服务端可能建立了一个链接，资源浪费")]),v._v(" "),_("p",[_("em",[v._v("同步双初识序列号")]),v._v(" "),_("code",[v._v("TCP")]),v._v("协议的双方，都必须维护一个序列号，序列号是可靠传输的一个关键因素，它的作用：")]),v._v(" "),_("ul",[_("li",[v._v("接收方可以去除重复的数据")]),v._v(" "),_("li",[v._v("接收方可以根据数据包的序列号按序接收")]),v._v(" "),_("li",[v._v("可以标识发送出去的数据包中，那些事已经被对方接收到\n三次握手的过程就是把服务端的自己的序列号和确认应答号一次性发送了出去。")])]),v._v(" "),_("p",[_("em",[v._v("避免资源浪费")])]),v._v(" "),_("h2",{attrs:{id:"四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[v._v("#")]),v._v(" 四次挥手")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("client                                      server\n主动关闭 →          FIN=1,seq=u          → 被动关闭，接收\n(终止等待1)                               (关闭等待)\n接收     ←      ACK=1,seq=v,ack=u+1      ← 发送\n(终止等待2)                               (关闭等待)\n接收     ←   FIN=1,ACK=1,seq=w,ack=u+1   ← 发送\n(时间等待)                                (最后确认)\n发送     →      ACK=1,seq=u+1,ack=w+1    → 接收\n(时间等待 2MSL 关闭)                      (关闭)\n")])])]),_("ul",[_("li",[v._v("第一次挥手： 客户端发送释放标识"),_("code",[v._v("FIN=1")]),v._v("，自己的序列号"),_("code",[v._v("seq=u")]),v._v("，进入终止等待状态"),_("code",[v._v("FIN-WAIT-1")])]),v._v(" "),_("li",[v._v("第二次挥手: 服务端收到消息后发送"),_("code",[v._v("ACK=1")]),v._v("确认标识和客户端的确认号"),_("code",[v._v("ack=u+1")]),v._v(",自己的序列号"),_("code",[v._v("seq=v")]),v._v(",进入关闭等待状态"),_("code",[v._v("COLOSE-WAIT")]),v._v("，客户端收到消息后进入终止等待状态"),_("code",[v._v("FIN-WAIT-2")])]),v._v(" "),_("li",[v._v("第三次挥手: 服务端处理完并发送需要处理的数据，发送释放标识"),_("code",[v._v("FIN=1")]),v._v(",确认序列号"),_("code",[v._v("ack=u+1")]),v._v(",自己的序列号"),_("code",[v._v("seq=w")]),v._v(",服务端进入最后确认"),_("code",[v._v("LAST-ACK")]),v._v("状态")]),v._v(" "),_("li",[v._v("第四次挥手: 客户端收到回复后，发送确认标识"),_("code",[v._v("ACK=1")]),v._v("，确认序号"),_("code",[v._v("ack=w+1")]),v._v(",自己的序列号"),_("code",[v._v("seq=u+1")]),v._v(",客户端进入时间等待状态"),_("code",[v._v("TIME-WAIT")]),v._v(",经过2个最长报文段寿命后，客户端"),_("code",[v._v("CLOSE")]),v._v("。服务端收到确认后，立即进入"),_("code",[v._v("CLOSE")]),v._v("状态")])]),v._v(" "),_("h2",{attrs:{id:"为什么需要等待2msl"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要等待2msl"}},[v._v("#")]),v._v(" 为什么需要等待2MSL")]),v._v(" "),_("p",[v._v("防止服务端一直没收到客户端最后的ACK报文而一直处于最后确认状态，当服务端没接收重新发送释放FIN报文，要保证2MSL时间确保服务端报文到达客户端。")]),v._v(" "),_("h2",{attrs:{id:"参考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("https://www.zhihu.com/question/24853633\nhttps://www.cnblogs.com/jainszhang/p/10641728.html\nhttps://blog.csdn.net/jun2016425/article/details/81506353\nhttps://blog.csdn.net/qq_38950316/article/details/81087809\nhttps://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%A4%B4%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B\n")])])])])}),[],!1,null,null,null);_.default=a.exports}}]);