(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{430:function(t,s,a){"use strict";a.r(s);var e=a(2),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"usememo与usecallback"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usememo与usecallback"}},[t._v("#")]),t._v(" useMemo与useCallback")]),t._v(" "),s("p",[s("code",[t._v("useMemo")]),t._v("和"),s("code",[t._v("useCallback")]),t._v("都可缓存函数的引用或值，从更细的角度来说"),s("code",[t._v("useMemo")]),t._v("则返回一个缓存的值，"),s("code",[t._v("useCallback")]),t._v("是返回一个缓存函数的引用。")]),t._v(" "),s("h2",{attrs:{id:"usememo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usememo"}},[t._v("#")]),t._v(" useMemo")]),t._v(" "),s("p",[s("code",[t._v("useMemo")]),t._v("的"),s("code",[t._v("TS")]),t._v("定义可以看出，范型"),s("code",[t._v("T")]),t._v("在"),s("code",[t._v("useMemo")]),t._v("中是一个返回的值类型。")]),t._v(" "),s("div",{staticClass:"language-ts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ts"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DependencyList")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ReadonlyArray"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token generic-function"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useMemo")]),s("span",{pre:!0,attrs:{class:"token generic class-name"}},[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("factory")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" deps"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" DependencyList "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("下面是"),s("code",[t._v("useMemo")]),t._v("的简单示例，在"),s("code",[t._v("a")]),t._v("和"),s("code",[t._v("b")]),t._v("的变量值不变的情况下，"),s("code",[t._v("memoizedValue")]),t._v("的值不变，在此时"),s("code",[t._v("useMemo")]),t._v("函数的第一个参数也就是"),s("code",[t._v("computeExpensiveValue")]),t._v("函数不会被执行，从而达到节省计算量的目的。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" memoizedValue "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useMemo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("computeExpensiveValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("把创建函数"),s("code",[t._v("factory: () => T")]),t._v("和依赖项数组"),s("code",[t._v("deps: DependencyList | undefined")]),t._v("作为参数传入 "),s("code",[t._v("useMemo")]),t._v("，它仅会在某个依赖项改变时才重新计算"),s("code",[t._v("memoized")]),t._v(" 值，这种优化有助于避免在每次渲染时都进行高开销的计算，例如上文的"),s("code",[t._v("computeExpensiveValue")]),t._v("是需要一个大量计算的函数时，"),s("code",[t._v("useMemo")]),t._v("有助于减少性能开销，以防止"),s("code",[t._v("Js")]),t._v("太多次长时间运行计算导致页面无响应。"),s("br"),t._v("\n此外，传入"),s("code",[t._v("useMemo")]),t._v("的函数会在渲染期间执行，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于"),s("code",[t._v("useEffect")]),t._v("的适用范畴，而不是"),s("code",[t._v("useMemo")]),t._v("。如果没有提供依赖项数组，"),s("code",[t._v("useMemo")]),t._v("在每次渲染时都会计算新的值。\n"),s("code",[t._v("eslint")]),t._v("的"),s("code",[t._v("eslint-plugin-react-hooks")]),t._v("中的"),s("code",[t._v("exhaustive-deps")]),t._v("规则可以在添加错误依赖时发出警告并给出修复建议。"),s("br"),t._v("\n相比较于"),s("code",[t._v("useEffect")]),t._v("看起来和"),s("code",[t._v("Vue")]),t._v("的"),s("code",[t._v("Watch")]),t._v("很像，但是思想方面是不同的，"),s("code",[t._v("Vue")]),t._v("是监听值的变化而"),s("code",[t._v("React")]),t._v("是用以处理副作用。在"),s("code",[t._v("useMemo")]),t._v("方面就和"),s("code",[t._v("Vue")]),t._v("的"),s("code",[t._v("computed")]),t._v("非常类似了，同样都属于缓存依赖项的计算结果，当然在实现上是完全不同的。")]),t._v(" "),s("h2",{attrs:{id:"usecallback"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usecallback"}},[t._v("#")]),t._v(" useCallback")]),t._v(" "),s("p",[s("code",[t._v("useCallback")]),t._v("的"),s("code",[t._v("TS")]),t._v("定义可以看出，范型"),s("code",[t._v("T")]),t._v("在"),s("code",[t._v("useCallback")]),t._v("中是一个返回的函数类型。")]),t._v(" "),s("div",{staticClass:"language-ts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ts"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DependencyList")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ReadonlyArray"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" useCallback"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("callback"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" deps"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" DependencyList"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("下面是"),s("code",[t._v("useCallback")]),t._v("的简单示例，在"),s("code",[t._v("a")]),t._v("和"),s("code",[t._v("b")]),t._v("的变量值不变的情况下，"),s("code",[t._v("memoizedCallback")]),t._v("的函数引用不变，在此时"),s("code",[t._v("useCallback")]),t._v("函数的第一个参数不会被重新定义，即引用的依旧是原函数，从而达到性能优化的目的。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" memoizedCallback "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useCallback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doSomething")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("把内联回调函数"),s("code",[t._v("callback: T")]),t._v("及依赖项数组"),s("code",[t._v("deps: DependencyList")]),t._v("作为参数传入 "),s("code",[t._v("useCallback")]),t._v("，它将返回该回调函数的"),s("code",[t._v("memoized")]),t._v("版本，该回调函数仅在某个依赖项改变时才会更新，将回调函数传递给经过优化的并使用引用相等性去避免非必要渲染(例如"),s("code",[t._v("shouldComponentUpdate")]),t._v(")的子组件时，它将非常有用。此外，"),s("code",[t._v("useCallback(fn, deps)")]),t._v("相当于"),s("code",[t._v("useMemo(() => fn, deps)")]),t._v("，由此"),s("code",[t._v("useCallback")]),t._v("可以看作"),s("code",[t._v("useMemo")]),t._v("的语法糖。"),s("br"),t._v(" "),s("code",[t._v("eslint")]),t._v("的"),s("code",[t._v("eslint-plugin-react-hooks")]),t._v("中的"),s("code",[t._v("exhaustive-deps")]),t._v("规则可以在添加错误依赖时发出警告并给出修复建议。"),s("br"),t._v("\n在"),s("code",[t._v("useCallback")]),t._v("的应用方面，一般"),s("code",[t._v("Js")]),t._v("上创建一个函数需要的时间并不至于要缓存的程度，那为什么要专门给缓存函数的创建做一个语法糖呢，这就跟"),s("code",[t._v("React.memo")]),t._v("有关系了。"),s("code",[t._v("React.memo")]),t._v("的默认第二参数是浅对比"),s("code",[t._v("shallow compare")]),t._v("上次渲染的"),s("code",[t._v("props")]),t._v("和这次渲染的"),s("code",[t._v("props")]),t._v("，如果你的组件的"),s("code",[t._v("props")]),t._v("中包含一个回调函数，并且这个函数是在父组件渲染的过程中创建的(见下例)，那么每次父组件(下例中的"),s("code",[t._v("<MyComponent />")]),t._v("）渲染时，"),s("code",[t._v("React")]),t._v("是认为你的子组件(下例中的"),s("code",[t._v("<Button />")]),t._v(")"),s("code",[t._v("props")]),t._v("是有变化的，不管你是否对这个子组件用了"),s("code",[t._v("React.memo")]),t._v("，都无法阻止重复渲染。这时就只能用"),s("code",[t._v("useCallback")]),t._v("来缓存这个回调函数，才会让"),s("code",[t._v("React")]),t._v("(或者说"),s("code",[t._v("Js")]),t._v(")认为这个"),s("code",[t._v("prop")]),t._v("和上次是相同的。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// 下面三种方法都会在MyComponent渲染的过程中重新创建这个回调函数\n// 这样都会引起Button的重新渲染 因为Button的props变化了\nfunction MyComponent() {\n  return <Button onClick={() => doWhatever()} />;\n}\n\nfunction MyComponent() {\n  const handleClick = () => doWhatever();\n  return <Button onClick={handleClick} />;\n}\n\nfunction MyComponent() {\n  function handleClick(){ \n    doWhatever();\n  }\n  return <Button onClick={handleClick} />;\n}\n\n// 只有使用useCallback， 才会导致即使MyComponent渲染，也不重新创建一个新的回调函数\n// 这样就不会引发Button的重新渲染 因为Button的props没变\nfunction MyComponent() {\n  const handleClick = React.useCallBack(() => doWhatever(), []);\n  return <Button onClick={handleClick} />;\n}\n")])])]),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[t._v("大部分的useMeno和useCallback都应该移除，他们可能没有带来任何性能上的优化，反而增加了程序首次渲染的负担，并增加程序的复杂性。\n使用useMemo和useCallback优化子组件re-render时，必须同时满足以下条件才有效：子组件已通过React.memo或者useMemo被缓存；子组件所有的prop都被缓存\n不推荐默认给所有组件都使用缓存，大量组件初始化时被缓存，可能导致过多的内存销毁，并影响程序初始化渲染的速度。")])])}),[],!1,null,null,null);s.default=n.exports}}]);