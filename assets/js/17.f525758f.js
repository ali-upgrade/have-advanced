(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{414:function(e,n,o){"use strict";o.r(n);var t=o(2),s=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"websocket"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[e._v("#")]),e._v(" websocket")]),e._v(" "),n("p",[e._v("webSocket是在应用层实现的协议。尽管WebSocket的握手过程使用了HTTP协议，但是一旦握手成功，WebSocket连接会升级为全双工的通讯通道，不再遵循HTTP协议的规则。在握手成功后，WebSocket协议会在应用层上定义消息格式和通信规则，通过TCP协议在传输层上进行数据传输。\n因此，WebSocket是在应用层实现的协议，它建立在传输层的TCP协议之上，使用HTTP协议进行握手，然后在建立的TCP连接上实现全双工的通信。在应用层上，WebSocket定义了一种标准的消息格式和通信规则，使得客户端和服务端可以通过发送和接收WebSocket消息来进行实时的双向通信。\n"),n("strong",[e._v("客户端")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//创建WebSocket对象，指定服务器的URL\nconst socket = new WebSocket("ws://localhost:8080")\n\n//连接建立时触发\nsocket.onopen = function(event) {\n  console.log("WebSocket连接已建立");\n\n  //发送消息给服务器\n  socket.send("Hello, Server")\n}\n\n// 接收到服务器发送的消息时触发\nsocket.onmessage = function(event) {\n  console.log("收到服务器的消息:" + event.data)\n};\n\n//连接关闭时触发\nsocket.onclose = function(event) {\n  console.log("WebSocket连接已关闭")\n}\n')])])]),n("p",[n("strong",[e._v("服务端")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const WebSocket = require('ws')\n\n//创建WebSocket服务器\nconst wss = new WebSocket.Server({ port: 8080 })\n\n//监听连接事件\nwss.on('connection', function connection(ws) {\n  console.log('WebSocket连接已建立')\n\n  //监听消息事件\n  ws.on('message', function incoming(message) {\n    console.log('收到客户端的消息: %s', message)\n\n    //发送消息给客户端\n    ws.send('hello, clint')\n  });\n\n  //监听关闭事件\n  ws.on('close', function close() {\n    console.log('WebSocket连接已关闭')\n  })\n})\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);