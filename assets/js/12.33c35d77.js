(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{402:function(t,e,n){t.exports=n.p+"assets/img/Snipaste_2024-03-01_10-51-19.be8d9cb2.png"},450:function(t,e,n){"use strict";n.r(e);var a=n(2),s=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"响应式原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#响应式原理"}},[t._v("#")]),t._v(" 响应式原理")]),t._v(" "),e("p",[t._v("Vue.js 3 采用 Proxy 实现响应式数据，这涉及语言规范层面的知识。这部分内容包括如何根据语言规范实现对数据对象的代理，以及其中的一些重要细节。接下来，我们就从认识响应式数据和副作用函数开始，一步一步地了解响应系统的设计与实现。")]),t._v(" "),e("h2",{attrs:{id:"响应式数据和副作用函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#响应式数据和副作用函数"}},[t._v("#")]),t._v(" 响应式数据和副作用函数")]),t._v(" "),e("p",[e("strong",[t._v("副作用函数")]),t._v("是指会产生副作用的函数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//这函数式存在副作用的，虽然它只会设置body的文本内容，不涉及外部状态的改变，但是除了effect函数之外的任何函数都可以读取设置body的文本内容。\nfunction effect() {\n    document.body.innerText = 'hello vue3'\n}\n// 副作用很容易产生，例如一个函数修改了全局变量，这其实也是一个副作用，\nlet val = 1\nfunction effect() {\n    val = 2\n}\n")])])]),e("p",[e("strong",[t._v("响应式数据")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//假设在一个副作用函数中读取了某个对象的属性\nconst obj = { text: 'hello world' }\nfunction effect() {\n    document.body.innerText = obj.text\n}\n")])])]),e("p",[t._v("如上面的代码所示，副作用函数effect会设置body元素的innerText属性，其值为obj.text,当obj.text的值发生变化时，我们希望副作用函数会重新执行")]),t._v(" "),e("h2",{attrs:{id:"响应式数据的基本实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#响应式数据的基本实现"}},[t._v("#")]),t._v(" 响应式数据的基本实现")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//存储副作用函数的桶\nconst bucket = new Set()\n\n//原始数据\nconst data = { text: 'hello world' } \n// 对原始数据的代理\nconst obj = new Proxy(data, {\n    //拦截读取操作\n    get(target, key) {\n        //将副作用函数添加到存储副作用函数的桶中\n        bucket.add(effect)\n        //返回属性值\n        return target[key]\n    },\n    //拦截设置操作\n    set(target, key, newVal) {\n        /设置属性值\n        target[key] = newVal\n        //把副作用函数从桶里取出并执行\n        bucket.forEach(fn => fn())\n        //返回true代表设置操作成功\n        return true\n    }\n})\n\n")])])]),e("p",[t._v("首先，我们创建了一个用于存储副作用函数的桶 bucket，它是Set 类型。接着定义原始数据 data，obj 是原始数据的代理对象，我们分别设置了 get 和 set 拦截函数，用于拦截读取和设置操作。当读取属性时将副作用函数 effect 添加到桶里，即bucket.add(effect)，然后返回属性值；当设置属性值时先更新原始数据，再将副作用函数从桶里取出并重新执行，这样我们就实现了响应式数据。")]),t._v(" "),e("p",[e("strong",[t._v("缺陷")]),t._v("：副作用函数采用了硬编码的方式，导致名字不能修改")]),t._v(" "),e("p",[e("img",{attrs:{src:n(402),alt:"cache"}})]),t._v(" "),e("h2",{attrs:{id:"为什么使用reflect"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用reflect"}},[t._v("#")]),t._v(" 为什么使用Reflect")]),t._v(" "),e("p",[t._v("Reflect可以接收地第三个参数，即指定接收者"),e("strong",[t._v("receiver")]),t._v("，你可以把它理解为函数调用过程中的this。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" const obj = {\n   foo: 1, \n   get bar() { \n   // 这里的 this 指向的是谁？ \n   return this.foo\n    }\n}\n")])])]),e("p",[t._v("当我们通过obj.bar触发响应式时，不使用Reflect.get()完成读取，会导致getter函数内的this始终指向原始对象，这样就不会建立响应式联系。导致无法响应")])])}),[],!1,null,null,null);e.default=s.exports}}]);