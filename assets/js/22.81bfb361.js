(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{419:function(v,_,a){"use strict";a.r(_);var t=a(2),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"进程与线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[v._v("#")]),v._v(" 进程与线程")]),v._v(" "),_("h2",{attrs:{id:"进程与线程的概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程的概念"}},[v._v("#")]),v._v(" 进程与线程的概念")]),v._v(" "),_("p",[v._v("从本质上说，进程与线程都是CPU工作时间片的一个描述:")]),v._v(" "),_("ul",[_("li",[v._v("进程描述了CPU在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序")]),v._v(" "),_("li",[v._v("线程是进程中的更小单位，描述了执行一段指令所需要的时间")])]),v._v(" "),_("p",[_("em",[v._v("进程是资源分配的最小单位，线程是CPU调度的最小单位")])]),v._v(" "),_("p",[v._v("一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一个内存，用来存放代码，运行中的数据和一个执行任务的主线程，我们把这样的运行环境叫做进程。进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无线需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。")]),v._v(" "),_("p",[v._v("如果程序很多时，内存可能会不够，操作系统为每个进程提供了一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。")]),v._v(" "),_("p",[v._v("进程和线程之间的关系：")]),v._v(" "),_("ul",[_("li",[v._v("进程中任意一线程执行出错，都会导致整个进程的崩溃")]),v._v(" "),_("li",[v._v("线程之间共享进程中的数据")]),v._v(" "),_("li",[v._v("当一个进程关闭之后，操作系统会回收进程所占用的内存。当一个进程退出时，操作系统会回收该经常所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。")]),v._v(" "),_("li",[v._v("进程之间的内容相互隔离。进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程A写入数据到进程B的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要数据通信，这时候，就需要使用用于进程间通讯的机制了。")])]),v._v(" "),_("h2",{attrs:{id:"浏览器架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器架构"}},[v._v("#")]),v._v(" 浏览器架构")]),v._v(" "),_("ul",[_("li",[v._v("1个浏览器主进程"),_("code",[v._v("Browser Process")])]),v._v(" "),_("li",[v._v("1个GPU进程"),_("code",[v._v("GPU Process")])]),v._v(" "),_("li",[v._v("1个网络进程"),_("code",[v._v("NetWork Process")])]),v._v(" "),_("li",[v._v("多个渲染进程"),_("code",[v._v("Render Process")])]),v._v(" "),_("li",[v._v("多个插件进程"),_("code",[v._v("Plugin Process")])])]),v._v(" "),_("p",[v._v("这些进程的功能:")]),v._v(" "),_("ul",[_("li",[_("em",[v._v("浏览器进程")]),v._v("：主要负责界面显示，用户交互，子进程管理，同时提供存储等功能")]),v._v(" "),_("li",[_("em",[v._v("渲染进程")]),v._v(": 核心任务是将HTML,CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下")]),v._v(" "),_("li",[_("em",[v._v("GPU进程")]),v._v(": 其实，GUP的使用初衷是为了实现3D CSS的效果，只是随后网页，Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上引入了GPU进程")]),v._v(" "),_("li",[_("em",[v._v("网络进程")]),v._v("：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直到最近才独立出来，成为一个单独的进程")]),v._v(" "),_("li",[_("em",[v._v("插件进程")]),v._v("：这样负责插件的运行，因为插件易崩溃，所以需要通过插件进程来隔离，以确保插件进程崩溃不会对浏览器和页面造成影响。")])]),v._v(" "),_("p",[v._v("所以，打开一个网页，最少需要四个进程：一个网络进程，一个浏览器进程，一个GPU进程以及一个渲染进程。如果打开的页面有运行插件的话，还需要再加上一个插件进程。")]),v._v(" "),_("p",[v._v("虽然多进程模式提升了浏览器的稳定性，流畅性和安全性，但同样不可避免地带来了一些问题：")]),v._v(" "),_("ul",[_("li",[v._v("更高的资源占用：因为每个进程都会包含公共基础结构的副本"),_("code",[v._v("如JavaScript运行环境")]),v._v(",这意味着浏览器会销毁更多的内存资源")]),v._v(" "),_("li",[v._v("更复杂的体系架构：浏览器各模块之间耦合性高，扩展性差等问题，会导致现在的架构已经很难适应新的需求")])]),v._v(" "),_("h2",{attrs:{id:"进程与线程的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程的区别"}},[v._v("#")]),v._v(" 进程与线程的区别")]),v._v(" "),_("ul",[_("li",[v._v("进程可以看做独立应用，线程不能")]),v._v(" "),_("li",[v._v("资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）")]),v._v(" "),_("li",[v._v("通讯方面：线程间可以通过直接共享同一进程中的资源，而进程通讯需要借助进程间通讯")]),v._v(" "),_("li",[v._v("调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。")]),v._v(" "),_("li",[v._v("系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存，I/O等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程CPU环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小")])]),v._v(" "),_("h2",{attrs:{id:"浏览器渲染进程的线程有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染进程的线程有哪些"}},[v._v("#")]),v._v(" 浏览器渲染进程的线程有哪些")]),v._v(" "),_("ul",[_("li",[_("em",[v._v("GUI渲染线程")]),v._v("负责渲染浏览器页面，解析HTML,CSS,构建DOM树，构建CSSOM树，构建渲染树和绘制页面；当前页面需要重绘或由于某种操作引发回流时，该线程会执行")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行是GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行\n")])])]),_("ul",[_("li",[_("em",[v._v("JS引擎线程")]),v._v("JS引擎线程也称为JS内核，负责处理JavaScript脚本程序，解析JavaScript脚本，运行代码；JS引擎线程一直等待这任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序")]),v._v(" "),_("li",[_("em",[v._v("事件触发线程")]),v._v("属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程，如鼠标点击，AJAX异步请求等），就会将对应任务添加到事件触发线程中；当对应的事件符合触发条件时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理\n")])])]),_("ul",[_("li",[_("em",[v._v("定时器触发线程")]),v._v("即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准确执行，定时器只是在指定时间点将任务添加到事件队列中；")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("W3C在HTML标准中规定，定时器的定时事件不能小于4ms，如果小于4ms，则默认为4ms\n")])])]),_("ul",[_("li",[v._v("异步HTTP请求线程\nXMLHttpRequest连接后通过浏览器新开一个线程请求\n检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列，等待JS引擎空闲后执行")])]),v._v(" "),_("h2",{attrs:{id:"进程之前的通信方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程之前的通信方式"}},[v._v("#")]),v._v(" 进程之前的通信方式")]),v._v(" "),_("h3",{attrs:{id:"管道通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#管道通信"}},[v._v("#")]),v._v(" 管道通信")]),v._v(" "),_("p",[v._v("管道是一种最基本的进程间通信机制。管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了")]),v._v(" "),_("p",[v._v("管道的特点")]),v._v(" "),_("ul",[_("li",[v._v("只能单向通信")]),v._v(" "),_("li",[v._v("只能依靠血缘关系的进程进行通信")]),v._v(" "),_("li",[v._v("依赖于文件系统")]),v._v(" "),_("li",[v._v("生命周期随进程")]),v._v(" "),_("li",[v._v("面向字节流的服务")]),v._v(" "),_("li",[v._v("管道内部提供了同步机制")])]),v._v(" "),_("h3",{attrs:{id:"消息队列通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息队列通信"}},[v._v("#")]),v._v(" 消息队列通信")]),v._v(" "),_("p",[v._v("消息队列就是一个消息的列表。用户可以在消息队列中添加，读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送信息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有最大长度限制。")]),v._v(" "),_("h3",{attrs:{id:"信号量通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#信号量通信"}},[v._v("#")]),v._v(" 信号量通信")]),v._v(" "),_("p",[v._v("共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。")]),v._v(" "),_("h3",{attrs:{id:"信号通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#信号通信"}},[v._v("#")]),v._v(" 信号通信")]),v._v(" "),_("p",[v._v("信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。")]),v._v(" "),_("h3",{attrs:{id:"共享内存通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#共享内存通信"}},[v._v("#")]),v._v(" 共享内存通信")]),v._v(" "),_("p",[v._v("共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。")]),v._v(" "),_("h3",{attrs:{id:"套接字通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#套接字通信"}},[v._v("#")]),v._v(" 套接字通信")]),v._v(" "),_("p",[v._v("上面说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。")])])}),[],!1,null,null,null);_.default=s.exports}}]);